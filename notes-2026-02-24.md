# Who Calls `IrBuilder::RunImpl()`?

You're correct that the pattern is similar to LLVM's FunctionPass. `IrBuilder` inherits from `Optimization` (which inherits from `Pass`), and it works on a per-method basis. Here's how it gets invoked:

## The Call Chain

1. **Top Level: `OptimizeBytecode()` or `OptimizePandaFile()`** (in `bytecode_optimizer/optimize_bytecode.cpp`)

   This is the main entry point that processes an entire `.abc` file:
   ```cpp
   bool OptimizePandaFile(pandasm::Program *prog, const pandasm::AsmEmitter::PandaFileToPandaAsmMaps *maps,
                          const std::string &pfile_name, bool is_dynamic)
   {
       auto pfile = panda_file::OpenPandaFile(pfile_name);

       for (uint32_t id : pfile->GetClasses()) {          // Iterate over all classes
           panda_file::ClassDataAccessor cda {*pfile, record_id};
           cda.EnumerateMethods([...](panda_file::MethodDataAccessor &mda) {  // Iterate over methods in each class
               OptimizeFunction(prog, maps, mda, is_dynamic);
           });
       }
   }
   ```

2. **Per-Method: `OptimizeFunction()`** creates a `Graph` and runs `IrBuilder`:
   ```cpp
   bool OptimizeFunction(...) {
       auto graph = allocator.New<compiler::Graph>(&allocator, &local_allocator, Arch::NONE,
                                                    method_ptr, &adapter, ...);

       if (!graph->RunPass<panda::compiler::IrBuilder>()) {  // <-- This triggers IrBuilder::RunImpl()
           LOG(ERROR, BYTECODE_OPTIMIZER) << "IR builder failed!";
           return false;
       }
       // ... more optimization passes follow
   }
   ```

3. **`Graph::RunPass<IrBuilder>()`** is a template method that:
   - Instantiates `IrBuilder(graph)`
   - Calls `IrBuilder::RunImpl()`

## The Scheduler Pattern

The "scheduler" you're looking for is the **two-level iteration**:
- **Outer loop**: `pfile->GetClasses()` – iterates over all class IDs in the abc file
- **Inner loop**: `ClassDataAccessor::EnumerateMethods()` – iterates over all methods within each class

This is defined in `libpandafile/class_data_accessor-inl.h` and reads directly from the abc file format.

---

# Why Only Methods? What About Classes, Modules, Namespaces?

This is the key insight you're asking about. Here's why:

## The Compilation Model

In the ArkCompiler/Panda model, **all executable code lives in methods**. The higher-level constructs (modules, classes, namespaces) are **metadata containers**, not executable entities:

| Construct | What It Contains |
|-----------|-----------------|
| **Module** | Import/export declarations, module record info |
| **Class** | Fields, method references, annotations |
| **Namespace** | Scoping information (lowered away by frontend) |
| **Function** | Becomes a **Method** with actual bytecode |

## What Happens During abc File Generation (ets_frontend)

When the frontend compiles ArkTS source to abc bytecode:

1. **Classes** become `ClassDataAccessor` entries in the abc file, containing:
   - Field definitions
   - Method references (pointers to actual method bytecode)
   - Type annotations

2. **Modules** become `ModuleDataAccessor` entries containing:
   - Import/export tables
   - Module request lists
   - These are stored as **metadata fields** on a "record" class

3. **Namespaces** are typically **flattened** – they become name prefixes on methods/classes

4. **Functions** (including class methods, module-level functions, lambdas) become actual **Method** entries with:
   - Bytecode instructions
   - Register counts
   - Exception handler tables
   - Debug info

## The Key Realization

**Only methods contain executable bytecode**. Classes, modules, and namespaces don't have "code" to optimize – they're just organizational structures. By the time you're at the abc bytecode level:

- A class is just a table of field descriptors and method IDs
- A module is just import/export metadata
- A namespace doesn't even exist as a separate entity

So the IR builder legitimately only needs to work on methods because that's where all the actual instructions live.

## Example: What a Class Looks Like in abc

```
Class "MyClass":
  - field_0: int "x"
  - field_1: string "name"
  - method_0 -> Method@0x1234 "constructor"
  - method_1 -> Method@0x5678 "doSomething"

Method@0x1234:
  [actual bytecode instructions]

Method@0x5678:
  [actual bytecode instructions]
```

The class itself has no code – it's just a manifest pointing to methods. The IR builder processes `Method@0x1234` and `Method@0x5678` separately, building a CFG for each.

## Summary

Your intuition about this being like LLVM's FunctionPass is correct:
- LLVM operates on Functions (the unit of code)
- Panda operates on Methods (the unit of code)
- Higher-level constructs (modules, classes) are metadata that inform the method compilation but don't themselves get compiled
